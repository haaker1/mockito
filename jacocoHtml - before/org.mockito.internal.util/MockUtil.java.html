<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="sv"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MockUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mockito</a> &gt; <a href="index.source.html" class="el_package">org.mockito.internal.util</a> &gt; <span class="el_source">MockUtil.java</span></div><h1>MockUtil.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2007 Mockito contributors
 * This program is made available under the terms of the MIT License.
 */
package org.mockito.internal.util;

import org.mockito.MockedConstruction;
import org.mockito.Mockito;
import org.mockito.exceptions.misusing.NotAMockException;
import org.mockito.internal.configuration.plugins.DefaultMockitoPlugins;
import org.mockito.internal.configuration.plugins.Plugins;
import org.mockito.internal.creation.settings.CreationSettings;
import org.mockito.internal.stubbing.InvocationContainerImpl;
import org.mockito.internal.util.reflection.LenientCopyTool;
import org.mockito.invocation.MockHandler;
import org.mockito.mock.MockCreationSettings;
import org.mockito.mock.MockName;
import org.mockito.plugins.MockMaker;
import org.mockito.plugins.MockMaker.TypeMockability;
import org.mockito.plugins.MockResolver;

import java.util.Collections;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Function;

import static org.mockito.internal.handler.MockHandlerFactory.createMockHandler;

@SuppressWarnings(&quot;unchecked&quot;)
public class MockUtil {

<span class="fc" id="L32">    private static final MockMaker defaultMockMaker = Plugins.getMockMaker();</span>
<span class="fc" id="L33">    private static final Map&lt;Class&lt;? extends MockMaker&gt;, MockMaker&gt; mockMakers =</span>
            new ConcurrentHashMap&lt;&gt;(
<span class="fc" id="L35">                    Collections.singletonMap(defaultMockMaker.getClass(), defaultMockMaker));</span>

    private MockUtil() {}

    public static MockMaker getMockMaker(String mockMaker) {
<span class="fc bfc" id="L40" title="All 2 branches covered.">        if (mockMaker == null) {</span>
<span class="fc" id="L41">            return defaultMockMaker;</span>
        }

        String typeName;
<span class="fc bfc" id="L45" title="All 2 branches covered.">        if (DefaultMockitoPlugins.MOCK_MAKER_ALIASES.contains(mockMaker)) {</span>
<span class="fc" id="L46">            typeName = DefaultMockitoPlugins.getDefaultPluginClass(mockMaker);</span>
        } else {
<span class="fc" id="L48">            typeName = mockMaker;</span>
        }

        Class&lt;? extends MockMaker&gt; type;
        // Using the context class loader because PluginInitializer.loadImpl is using it as well.
        // Personally, I am suspicious whether the context class loader is a good choice in either
        // of these cases.
<span class="fc" id="L55">        ClassLoader loader = Thread.currentThread().getContextClassLoader();</span>
<span class="pc bpc" id="L56" title="1 of 2 branches missed.">        if (loader == null) {</span>
<span class="nc" id="L57">            loader = ClassLoader.getSystemClassLoader();</span>
        }
        try {
<span class="fc" id="L60">            type = loader.loadClass(typeName).asSubclass(MockMaker.class);</span>
<span class="fc" id="L61">        } catch (Exception e) {</span>
<span class="fc" id="L62">            throw new IllegalStateException(&quot;Failed to load MockMaker: &quot; + mockMaker, e);</span>
<span class="fc" id="L63">        }</span>

<span class="fc" id="L65">        return mockMakers.computeIfAbsent(</span>
                type,
                t -&gt; {
                    try {
<span class="fc" id="L69">                        return t.getDeclaredConstructor().newInstance();</span>
<span class="fc" id="L70">                    } catch (Exception e) {</span>
<span class="fc" id="L71">                        throw new IllegalStateException(</span>
<span class="fc" id="L72">                                &quot;Failed to construct MockMaker: &quot; + t.getName(), e);</span>
                    }
                });
    }

    public static TypeMockability typeMockabilityOf(Class&lt;?&gt; type, String mockMaker) {
<span class="fc" id="L78">        return getMockMaker(mockMaker).isTypeMockable(type);</span>
    }

    public static &lt;T&gt; T createMock(MockCreationSettings&lt;T&gt; settings) {
<span class="fc" id="L82">        MockMaker mockMaker = getMockMaker(settings.getMockMaker());</span>
<span class="fc" id="L83">        MockHandler mockHandler = createMockHandler(settings);</span>

<span class="fc" id="L85">        Object spiedInstance = settings.getSpiedInstance();</span>

        T mock;
<span class="fc bfc" id="L88" title="All 2 branches covered.">        if (spiedInstance != null) {</span>
<span class="fc" id="L89">            mock =</span>
                    mockMaker
<span class="fc" id="L91">                            .createSpy(settings, mockHandler, (T) spiedInstance)</span>
<span class="fc" id="L92">                            .orElseGet(</span>
                                    () -&gt; {
<span class="nc" id="L94">                                        T instance = mockMaker.createMock(settings, mockHandler);</span>
<span class="nc" id="L95">                                        new LenientCopyTool().copyToMock(spiedInstance, instance);</span>
<span class="nc" id="L96">                                        return instance;</span>
                                    });
        } else {
<span class="fc" id="L99">            mock = mockMaker.createMock(settings, mockHandler);</span>
        }

<span class="fc" id="L102">        return mock;</span>
    }

    public static void resetMock(Object mock) {
<span class="fc" id="L106">        MockHandler oldHandler = getMockHandler(mock);</span>
<span class="fc" id="L107">        MockCreationSettings settings = oldHandler.getMockSettings();</span>
<span class="fc" id="L108">        MockHandler newHandler = createMockHandler(settings);</span>

<span class="fc" id="L110">        mock = resolve(mock);</span>
<span class="fc" id="L111">        getMockMaker(settings.getMockMaker()).resetMock(mock, newHandler, settings);</span>
<span class="fc" id="L112">    }</span>

    public static MockHandler&lt;?&gt; getMockHandler(Object mock) {
<span class="fc" id="L115">        MockHandler handler = getMockHandlerOrNull(mock);</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">        if (handler != null) {</span>
<span class="fc" id="L117">            return handler;</span>
        } else {
<span class="fc" id="L119">            throw new NotAMockException(&quot;Argument should be a mock, but is: &quot; + mock.getClass());</span>
        }
    }

    public static InvocationContainerImpl getInvocationContainer(Object mock) {
<span class="fc" id="L124">        return (InvocationContainerImpl) getMockHandler(mock).getInvocationContainer();</span>
    }

    public static boolean isSpy(Object mock) {
<span class="fc bfc" id="L128" title="All 2 branches covered.">        return isMock(mock)</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">                &amp;&amp; getMockSettings(mock).getDefaultAnswer() == Mockito.CALLS_REAL_METHODS;</span>
    }

    public static boolean isMock(Object mock) {
        // TODO SF (perf tweak) in our codebase we call mockMaker.getHandler() multiple times
        // unnecessarily
        // This is not ideal because getHandler() can be expensive (reflective calls inside mock
        // maker)
        // The frequent pattern in the codebase are separate calls to: 1) isMock(mock) then 2)
        // getMockHandler(mock)
        // We could replace it with using mockingDetails().isMock()
        // Let's refactor the codebase and use new mockingDetails() in all relevant places.
        // Potentially we could also move other methods to MockitoMock, some other candidates:
        // getInvocationContainer, isSpy, etc.
        // This also allows us to reuse our public API MockingDetails
<span class="fc bfc" id="L144" title="All 2 branches covered.">        if (mock == null) {</span>
<span class="fc" id="L145">            return false;</span>
        }
<span class="fc bfc" id="L147" title="All 2 branches covered.">        return getMockHandlerOrNull(mock) != null;</span>
    }

    private static MockHandler&lt;?&gt; getMockHandlerOrNull(Object mock) {
<span class="fc bfc" id="L151" title="All 2 branches covered.">        if (mock == null) {</span>
<span class="fc" id="L152">            throw new NotAMockException(&quot;Argument should be a mock, but is null!&quot;);</span>
        }

<span class="fc" id="L155">        mock = resolve(mock);</span>

<span class="fc bfc" id="L157" title="All 2 branches covered.">        for (MockMaker mockMaker : mockMakers.values()) {</span>
<span class="fc" id="L158">            MockHandler&lt;?&gt; handler = mockMaker.getHandler(mock);</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">            if (handler != null) {</span>
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">                assert getMockMaker(handler.getMockSettings().getMockMaker()) == mockMaker;</span>
<span class="fc" id="L161">                return handler;</span>
            }
<span class="fc" id="L163">        }</span>
<span class="fc" id="L164">        return null;</span>
    }

    private static Object resolve(Object mock) {
<span class="fc bfc" id="L168" title="All 2 branches covered.">        if (mock instanceof Class&lt;?&gt;) { // static mocks are resolved by definition</span>
<span class="fc" id="L169">            return mock;</span>
        }
<span class="fc bfc" id="L171" title="All 2 branches covered.">        for (MockResolver mockResolver : Plugins.getMockResolvers()) {</span>
<span class="fc" id="L172">            mock = mockResolver.resolve(mock);</span>
<span class="fc" id="L173">        }</span>
<span class="fc" id="L174">        return mock;</span>
    }

    public static boolean areSameMocks(Object mockA, Object mockB) {
<span class="fc bfc" id="L178" title="All 4 branches covered.">        return mockA == mockB || resolve(mockA) == resolve(mockB);</span>
    }

    public static MockName getMockName(Object mock) {
<span class="fc" id="L182">        return getMockHandler(mock).getMockSettings().getMockName();</span>
    }

    public static void maybeRedefineMockName(Object mock, String newName) {
<span class="fc" id="L186">        MockName mockName = getMockName(mock);</span>
        // TODO SF hacky...
<span class="fc" id="L188">        MockCreationSettings mockSettings = getMockHandler(mock).getMockSettings();</span>
<span class="pc bpc" id="L189" title="1 of 4 branches missed.">        if (mockName.isDefault() &amp;&amp; mockSettings instanceof CreationSettings) {</span>
<span class="fc" id="L190">            ((CreationSettings) mockSettings).setMockName(new MockNameImpl(newName));</span>
        }
<span class="fc" id="L192">    }</span>

    public static MockCreationSettings getMockSettings(Object mock) {
<span class="fc" id="L195">        return getMockHandler(mock).getMockSettings();</span>
    }

    public static &lt;T&gt; MockMaker.StaticMockControl&lt;T&gt; createStaticMock(
            Class&lt;T&gt; type, MockCreationSettings&lt;T&gt; settings) {
<span class="fc" id="L200">        MockMaker mockMaker = getMockMaker(settings.getMockMaker());</span>
<span class="fc" id="L201">        MockHandler&lt;T&gt; handler = createMockHandler(settings);</span>
<span class="fc" id="L202">        return mockMaker.createStaticMock(type, settings, handler);</span>
    }

    public static &lt;T&gt; MockMaker.ConstructionMockControl&lt;T&gt; createConstructionMock(
            Class&lt;T&gt; type,
            Function&lt;MockedConstruction.Context, MockCreationSettings&lt;T&gt;&gt; settingsFactory,
            MockedConstruction.MockInitializer&lt;T&gt; mockInitializer) {
<span class="fc" id="L209">        Function&lt;MockedConstruction.Context, MockHandler&lt;T&gt;&gt; handlerFactory =</span>
<span class="fc" id="L210">                context -&gt; createMockHandler(settingsFactory.apply(context));</span>
<span class="fc" id="L211">        return defaultMockMaker.createConstructionMock(</span>
                type, settingsFactory, handlerFactory, mockInitializer);
    }

    public static void clearAllCaches() {
<span class="fc bfc" id="L216" title="All 2 branches covered.">        for (MockMaker mockMaker : mockMakers.values()) {</span>
<span class="fc" id="L217">            mockMaker.clearAllCaches();</span>
<span class="fc" id="L218">        }</span>
<span class="fc" id="L219">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>