<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>InvocationMatcher.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mockito</a> &gt; <a href="index.source.html" class="el_package">org.mockito.internal.invocation</a> &gt; <span class="el_source">InvocationMatcher.java</span></div><h1>InvocationMatcher.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2007 Mockito contributors
 * This program is made available under the terms of the MIT License.
 */
package org.mockito.internal.invocation;

import static org.mockito.internal.invocation.MatcherApplicationStrategy.getMatcherApplicationStrategyFor;
import static org.mockito.internal.invocation.TypeSafeMatching.matchesTypeSafe;

import java.io.Serializable;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;

import org.mockito.ArgumentMatcher;
import org.mockito.internal.matchers.CapturesArguments;
import org.mockito.internal.reporting.PrintSettings;
import org.mockito.invocation.DescribedInvocation;
import org.mockito.invocation.Invocation;
import org.mockito.invocation.Location;
import org.mockito.invocation.MatchableInvocation;

/**
 * In addition to all content of the invocation, the invocation matcher contains the argument matchers. Invocation matcher is used during verification and stubbing. In those cases, the user can provide argument matchers instead of 'raw' arguments. Raw arguments are converted to 'equals' matchers anyway.
 */
@SuppressWarnings(&quot;serial&quot;)
public class InvocationMatcher implements MatchableInvocation, DescribedInvocation, Serializable {

    private final Invocation invocation;
    private final List&lt;ArgumentMatcher&lt;?&gt;&gt; matchers;

    @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
<span class="fc" id="L35">    public InvocationMatcher(Invocation invocation, List&lt;ArgumentMatcher&gt; matchers) {</span>
<span class="fc" id="L36">        this.invocation = invocation;</span>
<span class="fc bfc" id="L37" title="All 2 branches covered.">        if (matchers.isEmpty()) {</span>
<span class="fc" id="L38">            this.matchers = (List) invocation.getArgumentsAsMatchers();</span>
        } else {
<span class="fc" id="L40">            this.matchers = (List) matchers;</span>
        }
<span class="fc" id="L42">    }</span>

    @SuppressWarnings(&quot;rawtypes&quot;)
    public InvocationMatcher(Invocation invocation) {
<span class="fc" id="L46">        this(invocation, Collections.&lt;ArgumentMatcher&gt;emptyList());</span>
<span class="fc" id="L47">    }</span>

    public static List&lt;InvocationMatcher&gt; createFrom(List&lt;Invocation&gt; invocations) {
<span class="fc" id="L50">        LinkedList&lt;InvocationMatcher&gt; out = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L51" title="All 2 branches covered.">        for (Invocation i : invocations) {</span>
<span class="fc" id="L52">            out.add(new InvocationMatcher(i));</span>
<span class="fc" id="L53">        }</span>
<span class="fc" id="L54">        return out;</span>
    }

    public Method getMethod() {
<span class="fc" id="L58">        return invocation.getMethod();</span>
    }

    @Override
    public Invocation getInvocation() {
<span class="fc" id="L63">        return invocation;</span>
    }

    @Override
    @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
    public List&lt;ArgumentMatcher&gt; getMatchers() {
<span class="fc" id="L69">        return (List) matchers;</span>
    }

    @Override
    @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
    public String toString() {
<span class="fc" id="L75">        return new PrintSettings().print((List) matchers, invocation);</span>
    }

    @Override
    public boolean matches(Invocation candidate) {
<span class="fc bfc" id="L80" title="All 2 branches covered.">        return invocation.getMock() == candidate.getMock()</span>
<span class="fc bfc" id="L81" title="All 2 branches covered.">                &amp;&amp; hasSameMethod(candidate)</span>
<span class="fc bfc" id="L82" title="All 2 branches covered.">                &amp;&amp; argumentsMatch(candidate);</span>
    }

    /**
     * similar means the same method name, same mock, unverified and: if arguments are the same cannot be overloaded
     */
    @Override
    public boolean hasSimilarMethod(Invocation candidate) {
<span class="fc" id="L90">        String wantedMethodName = getMethod().getName();</span>
<span class="fc" id="L91">        String candidateMethodName = candidate.getMethod().getName();</span>

<span class="fc bfc" id="L93" title="All 2 branches covered.">        if (!wantedMethodName.equals(candidateMethodName)) {</span>
<span class="fc" id="L94">            return false;</span>
        }
<span class="fc bfc" id="L96" title="All 2 branches covered.">        if (candidate.isVerified()) {</span>
<span class="fc" id="L97">            return false;</span>
        }
<span class="fc bfc" id="L99" title="All 2 branches covered.">        if (getInvocation().getMock() != candidate.getMock()) {</span>
<span class="fc" id="L100">            return false;</span>
        }
<span class="fc bfc" id="L102" title="All 2 branches covered.">        if (hasSameMethod(candidate)) {</span>
<span class="fc" id="L103">            return true;</span>
        }

<span class="fc bfc" id="L106" title="All 2 branches covered.">        return !argumentsMatch(candidate);</span>
    }

    @Override
    public boolean hasSameMethod(Invocation candidate) {
        // not using method.equals() for 1 good reason:
        // sometimes java generates forwarding methods when generics are in play see
        // JavaGenericsForwardingMethodsTest
<span class="fc" id="L114">        Method m1 = invocation.getMethod();</span>
<span class="fc" id="L115">        Method m2 = candidate.getMethod();</span>

<span class="pc bpc" id="L117" title="1 of 4 branches missed.">        if (m1.getName() != null &amp;&amp; m1.getName().equals(m2.getName())) {</span>
            /* Avoid unnecessary cloning */
<span class="fc" id="L119">            Class&lt;?&gt;[] params1 = m1.getParameterTypes();</span>
<span class="fc" id="L120">            Class&lt;?&gt;[] params2 = m2.getParameterTypes();</span>
<span class="fc" id="L121">            return Arrays.equals(params1, params2);</span>
        }
<span class="fc" id="L123">        return false;</span>
    }

    @Override
    public Location getLocation() {
<span class="fc" id="L128">        return invocation.getLocation();</span>
    }

    @Override
    public void captureArgumentsFrom(Invocation invocation) {
<span class="fc" id="L133">        MatcherApplicationStrategy strategy =</span>
<span class="fc" id="L134">                getMatcherApplicationStrategyFor(invocation, matchers);</span>
<span class="fc" id="L135">        strategy.forEachMatcherAndArgument(captureArgument());</span>
<span class="fc" id="L136">    }</span>

    private ArgumentMatcherAction captureArgument() {
<span class="fc" id="L139">        return new ArgumentMatcherAction() {</span>

            @Override
            public boolean apply(ArgumentMatcher&lt;?&gt; matcher, Object argument) {
<span class="fc bfc" id="L143" title="All 2 branches covered.">                if (matcher instanceof CapturesArguments) {</span>
<span class="fc" id="L144">                    ((CapturesArguments) matcher).captureFrom(argument);</span>
                }

<span class="fc" id="L147">                return true;</span>
            }
        };
    }

    @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
    private boolean argumentsMatch(Invocation actual) {
<span class="fc" id="L154">        List matchers = getMatchers();</span>
<span class="fc" id="L155">        return getMatcherApplicationStrategyFor(actual, matchers)</span>
<span class="fc" id="L156">                .forEachMatcherAndArgument(matchesTypeSafe());</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>