<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ArgumentMatcher.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mockito</a> &gt; <a href="index.source.html" class="el_package">org.mockito</a> &gt; <span class="el_source">ArgumentMatcher.java</span></div><h1>ArgumentMatcher.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2016 Mockito contributors
 * This program is made available under the terms of the MIT License.
 */
package org.mockito;

/**
 * Allows creating customized argument matchers.
 * This API was changed in Mockito 2.1.0 in an effort to decouple Mockito from Hamcrest
 * and reduce the risk of version incompatibility.
 * Migration guide is included close to the bottom of this javadoc.
 * &lt;p&gt;
 * For non-trivial method arguments used in stubbing or verification, you have the following options
 * (in no particular order):
 * &lt;ul&gt;
 *     &lt;li&gt;refactor the code so that the interactions with collaborators are easier to test with mocks.
 *     Perhaps it is possible to pass a different argument to the method so that mocking is easier?
 *     If stuff is hard to test it usually indicates the design could be better, so do refactor for testability!
 *     &lt;/li&gt;
 *     &lt;li&gt;don't match the argument strictly, just use one of the lenient argument matchers like
 *     {@link Mockito#notNull()}. Some times it is better to have a simple test that works than
 *     a complicated test that seem to work.
 *     &lt;/li&gt;
 *     &lt;li&gt;implement equals() method in the objects that are used as arguments to mocks.
 *     Mockito naturally uses equals() for argument matching.
 *     Many times, this is option is clean and simple.
 *     &lt;/li&gt;
 *     &lt;li&gt;use {@link ArgumentCaptor} to capture the arguments and perform assertions on their state.
 *     Useful when you need to verify the arguments. Captor is not useful if you need argument matching for stubbing.
 *     Many times, this option leads to clean and readable tests with fine-grained validation of arguments.
 *     &lt;/li&gt;
 *     &lt;li&gt;use customized argument matchers by implementing {@link ArgumentMatcher} interface
 *     and passing the implementation to the {@link Mockito#argThat} method.
 *     This option is useful if custom matcher is needed for stubbing and can be reused a lot.
 *     Note that {@link Mockito#argThat} demonstrates &lt;b&gt;NullPointerException&lt;/b&gt; auto-unboxing caveat.
 *     &lt;/li&gt;
 *     &lt;li&gt;use an instance of hamcrest matcher and pass it to
 *     {@link org.mockito.hamcrest.MockitoHamcrest#argThat(org.hamcrest.Matcher)}
 *     Useful if you already have a hamcrest matcher. Reuse and win!
 *     Note that {@link org.mockito.hamcrest.MockitoHamcrest#argThat(org.hamcrest.Matcher)} demonstrates &lt;b&gt;NullPointerException&lt;/b&gt; auto-unboxing caveat.
 *     &lt;/li&gt;
 *     &lt;li&gt;Java 8 only - use a lambda in place of an {@link ArgumentMatcher} since {@link ArgumentMatcher}
 *     is effectively a functional interface. A lambda can be used with the {@link Mockito#argThat} method.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;
 * Implementations of this interface can be used with {@link ArgumentMatchers#argThat} method.
 * Use &lt;code&gt;toString()&lt;/code&gt; method for description of the matcher
 * - it is printed in verification errors.
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * class ListOfTwoElements implements ArgumentMatcher&amp;lt;List&amp;gt; {
 *     public boolean matches(List list) {
 *         return list.size() == 2;
 *     }
 *     public String toString() {
 *         //printed in verification errors
 *         return &quot;[list of 2 elements]&quot;;
 *     }
 * }
 *
 * List mock = mock(List.class);
 *
 * when(mock.addAll(argThat(new ListOfTwoElements()))).thenReturn(true);
 *
 * mock.addAll(Arrays.asList(&amp;quot;one&amp;quot;, &amp;quot;two&amp;quot;));
 *
 * verify(mock).addAll(argThat(new ListOfTwoElements()));
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * To keep it readable you can extract method, e.g:
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 *   verify(mock).addAll(&lt;b&gt;argThat(new ListOfTwoElements())&lt;/b&gt;);
 *   //becomes
 *   verify(mock).addAll(&lt;b&gt;listOfTwoElements()&lt;/b&gt;);
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * In Java 8 you can treat ArgumentMatcher as a functional interface
 * and use a lambda, e.g.:
 *
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 *   verify(mock).addAll(&lt;b&gt;argThat(list -&amp;gt; list.size() == 2)&lt;/b&gt;);
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;p&gt;
 * Read more about other matchers in javadoc for {@link ArgumentMatchers} class.
 * &lt;h2&gt;2.1.0 migration guide&lt;/h2&gt;
 *
 * All existing custom implementations of &lt;code&gt;ArgumentMatcher&lt;/code&gt; will no longer compile.
 * All locations where hamcrest matchers are passed to &lt;code&gt;argThat()&lt;/code&gt; will no longer compile.
 * There are 2 approaches to fix the problems:
 * &lt;ul&gt;
 * &lt;li&gt;a) Refactor the hamcrest matcher to Mockito matcher:
 * Use &quot;implements ArgumentMatcher&quot; instead of &quot;extends ArgumentMatcher&quot;.
 * Then refactor &lt;code&gt;describeTo()&lt;/code&gt; method into &lt;code&gt;toString()&lt;/code&gt; method.
 * &lt;/li&gt;
 * &lt;li&gt;
 * b) Use &lt;code&gt;org.mockito.hamcrest.MockitoHamcrest.argThat()&lt;/code&gt; instead of &lt;code&gt;Mockito.argThat()&lt;/code&gt;.
 * Ensure that there is &lt;a href=&quot;http://hamcrest.org/JavaHamcrest/&quot;&gt;hamcrest&lt;/a&gt; dependency on classpath
 * (Mockito does not depend on hamcrest any more).
 *
 * &lt;/li&gt;
 * &lt;/ul&gt;
 * What option is right for you? If you don't mind having a compile-time dependency for Hamcrest,
 * then the second option is probably right for you.
 * Your choice should not have a big impact and is fully reversible -
 * you can choose different option in future (and refactor the code)!
 *
 * @param &lt;T&gt; type of argument
 * @since 2.1.0
 */
@FunctionalInterface
public interface ArgumentMatcher&lt;T&gt; {

    /**
     * Informs if this matcher accepts the given argument.
     * &lt;p&gt;
     * The method should &lt;b&gt;never&lt;/b&gt; assert if the argument doesn't match. It
     * should only return false.
     * &lt;p&gt;
     * See the example in the top level javadoc for {@link ArgumentMatcher}
     *
     * @param argument
     *            the argument
     * @return true if this matcher accepts the given argument.
     */
    boolean matches(T argument);

    /**
     * The type of the argument this matcher matches.
     *
     * &lt;p&gt;This method is used to differentiate between a matcher used to match a raw vararg array parameter
     * from a matcher used to match a single value passed as a vararg parameter.
     *
     * &lt;p&gt;Where the matcher:
     * &lt;ul&gt;
     *     &lt;li&gt;is at the parameter index of a vararg parameter&lt;/li&gt;
     *     &lt;li&gt;is the last matcher passed&lt;/li&gt;
     *     &lt;li&gt;this method returns a type assignable to the vararg parameter's raw type, i.e. its array type.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * ...then the matcher is matched against the raw vararg parameter, rather than the first element of the raw parameter.
     *
     * &lt;p&gt;For example:
     *
     * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
     *  // Given vararg method with signature:
     *  int someVarargMethod(String... args);
     *
     *  // The following will match invocations with any number of parameters, i.e. any number of elements in the raw array.
     *  mock.someVarargMethod(isA(String[].class));
     *
     *  // The following will match invocations with a single parameter, i.e. one string in the raw array.
     *  mock.someVarargMethod(isA(String.class));
     *
     *  // The following will match invocations with two parameters, i.e. two strings in the raw array
     *  mock.someVarargMethod(isA(String.class), isA(String.class));
     * &lt;/code&gt;&lt;/pre&gt;
     *
     * &lt;p&gt;Only matcher implementations that can conceptually match a raw vararg parameter should override this method.
     *
     * @return the type this matcher handles. The default value of {@link Void} means the type is not known.
     * @since 4.11.0
     */
    default Class&lt;?&gt; type() {
<span class="fc" id="L167">        return Void.class;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>