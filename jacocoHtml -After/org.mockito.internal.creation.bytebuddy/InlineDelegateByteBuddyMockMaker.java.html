<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>InlineDelegateByteBuddyMockMaker.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mockito</a> &gt; <a href="index.source.html" class="el_package">org.mockito.internal.creation.bytebuddy</a> &gt; <span class="el_source">InlineDelegateByteBuddyMockMaker.java</span></div><h1>InlineDelegateByteBuddyMockMaker.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2016 Mockito contributors
 * This program is made available under the terms of the MIT License.
 */
package org.mockito.internal.creation.bytebuddy;

import net.bytebuddy.agent.ByteBuddyAgent;

import org.mockito.MockedConstruction;
import org.mockito.creation.instance.InstantiationException;
import org.mockito.creation.instance.Instantiator;
import org.mockito.exceptions.base.MockitoException;
import org.mockito.exceptions.base.MockitoInitializationException;
import org.mockito.exceptions.misusing.MockitoConfigurationException;
import org.mockito.internal.SuppressSignatureCheck;
import org.mockito.internal.configuration.plugins.Plugins;
import org.mockito.internal.creation.instance.ConstructorInstantiator;
import org.mockito.internal.util.Platform;
import org.mockito.internal.util.concurrent.DetachedThreadLocal;
import org.mockito.internal.util.concurrent.WeakConcurrentMap;
import org.mockito.invocation.MockHandler;
import org.mockito.mock.MockCreationSettings;
import org.mockito.plugins.InlineMockMaker;
import org.mockito.plugins.MemberAccessor;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.instrument.Instrumentation;
import java.lang.reflect.Constructor;
import java.lang.reflect.Modifier;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.BiConsumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.jar.JarOutputStream;

import static org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.EXCLUDES;
import static org.mockito.internal.util.StringUtil.join;

/**
 * Agent and subclass based mock maker.
 * &lt;p&gt;
 * This mock maker uses a combination of the Java instrumentation API and sub-classing rather than creating
 * a new sub-class to create a mock. This way, it becomes possible to mock final types and methods. This mock
 * maker &lt;strong&gt;must be activated explicitly&lt;/strong&gt; for supporting mocking final types and methods:
 * &lt;p&gt;
 * &lt;p&gt;
 * This mock maker can be activated by creating the file &lt;code&gt;/mockito-extensions/org.mockito.plugins.MockMaker&lt;/code&gt;
 * containing the text &lt;code&gt;mock-maker-inline&lt;/code&gt; or &lt;code&gt;org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker&lt;/code&gt;.
 * &lt;p&gt;
 * &lt;p&gt;
 * This mock maker will make a best effort to avoid subclass creation when creating a mock. Otherwise it will use the
 * &lt;code&gt;org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker&lt;/code&gt; to create the mock class. That means
 * that the following condition is true
 * &lt;p&gt;
 * &lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;java&quot;&gt;
 * class Foo { }
 * assert mock(Foo.class).getClass() == Foo.class;
 * &lt;/pre&gt;&lt;/code&gt;
 * &lt;p&gt;
 * unless any of the following conditions is met, in such case the mock maker &lt;em&gt;falls back&lt;/em&gt; to
 * the creation of a subclass.
 * &lt;p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;the type to mock is an abstract class.&lt;/li&gt;
 * &lt;li&gt;the mock is set to require additional interfaces.&lt;/li&gt;
 * &lt;li&gt;the mock is &lt;a href=&quot;#20&quot;&gt;explicitly set to support serialization&lt;/a&gt;.&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * &lt;p&gt;
 * Some type of the JDK cannot be mocked, this includes &lt;code&gt;Class&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, and wrapper types.
 * &lt;p&gt;
 * &lt;p&gt;
 * Nevertheless, final methods of such types are mocked when using the inlining mock maker. Mocking final types and enums
 * does however remain impossible when explicitly requiring serialization support or when adding ancillary interfaces.
 * &lt;p&gt;
 * &lt;p&gt;
 * Important behavioral changes when using inline-mocks:
 * &lt;ul&gt;
 * &lt;li&gt;Mockito is capable of mocking package-private methods even if they are defined in different packages than
 * the mocked type. Mockito voluntarily never mocks package-visible methods within &lt;code&gt;java.*&lt;/code&gt; packages.&lt;/li&gt;
 * &lt;li&gt;Additionally to final types, Mockito can now mock types that are not visible for extension; such types
 * include private types in a protected package.&lt;/li&gt;
 * &lt;li&gt;Mockito can no longer mock &lt;code&gt;native&lt;/code&gt; methods. Inline mocks require byte code manipulation of a
 * method where native methods do not offer any byte code to manipulate.&lt;/li&gt;
 * &lt;li&gt;Mockito can no longer strip &lt;code&gt;synchronized&lt;/code&gt; modifiers from mocked instances.&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * &lt;p&gt;
 * Note that inline mocks require a Java agent to be attached. Mockito will attempt an attachment of a Java agent upon
 * loading the mock maker for creating inline mocks. Such runtime attachment is only possible when using a JVM that
 * is part of a JDK or when using a Java 9 VM. When running on a non-JDK VM prior to Java 9, it is however possible to
 * manually add the &lt;a href=&quot;https://bytebuddy.net&quot;&gt;Byte Buddy Java agent jar&lt;/a&gt; using the &lt;code&gt;-javaagent&lt;/code&gt;
 * parameter upon starting the JVM. Furthermore, the inlining mock maker requires the VM to support class retransformation
 * (also known as HotSwap). All major VM distributions such as HotSpot (OpenJDK), J9 (IBM/Websphere) or Zing (Azul)
 * support this feature.
 */
@SuppressSignatureCheck
class InlineDelegateByteBuddyMockMaker
        implements ClassCreatingMockMaker, InlineMockMaker, Instantiator {

    private static final Instrumentation INSTRUMENTATION;

    private static final Throwable INITIALIZATION_ERROR;

    static {
        Instrumentation instrumentation;
<span class="fc" id="L113">        Throwable initializationError = null;</span>

        // ByteBuddy internally may attempt to fork a subprocess. In Java 11 and Java 19, the Java
        // process class observes the os.name system property to determine the OS and thus determine
        // how to fork a new process. If the user is stubbing System properties, they may clear
        // the existing System properties, which will cause this to fail. This is very much an
        // implementation detail, but it will result in Mockito failing to load with an error that
        // is not overly clear, so let's attempt to detect this issue ahead of time instead.
<span class="pc bpc" id="L121" title="1 of 2 branches missed.">        if (System.getProperty(&quot;os.name&quot;) == null) {</span>
<span class="nc" id="L122">            throw new IllegalStateException(</span>
<span class="nc" id="L123">                    join(</span>
                            &quot;The Byte Buddy agent cannot be loaded.&quot;,
                            &quot;&quot;,
                            &quot;To initialise the Byte Buddy agent, a subprocess may need to be created. To do this, the JVM requires &quot;
                                    + &quot;knowledge of the 'os.name' System property in most JRE implementations. This property is not present, &quot;
                                    + &quot;which means this operation will fail to complete. Please first make sure you are not clearing this &quot;
                                    + &quot;property anywhere, and failing that, raise a bug with your JVM vendor.&quot;));
        }

        try {
            try {
<span class="fc" id="L134">                instrumentation = ByteBuddyAgent.install();</span>
<span class="pc bpc" id="L135" title="1 of 2 branches missed.">                if (!instrumentation.isRetransformClassesSupported()) {</span>
<span class="nc" id="L136">                    throw new IllegalStateException(</span>
<span class="nc" id="L137">                            join(</span>
                                    &quot;Byte Buddy requires retransformation for creating inline mocks. This feature is unavailable on the current VM.&quot;,
                                    &quot;&quot;,
                                    &quot;You cannot use this mock maker on this VM&quot;));
                }
<span class="fc" id="L142">                File boot = File.createTempFile(&quot;mockitoboot&quot;, &quot;.jar&quot;);</span>
<span class="fc" id="L143">                boot.deleteOnExit();</span>
<span class="fc" id="L144">                JarOutputStream outputStream = new JarOutputStream(new FileOutputStream(boot));</span>
                try {
<span class="fc" id="L146">                    String source =</span>
                            &quot;org/mockito/internal/creation/bytebuddy/inject/MockMethodDispatcher&quot;;
<span class="fc" id="L148">                    InputStream inputStream =</span>
                            InlineDelegateByteBuddyMockMaker.class
<span class="fc" id="L150">                                    .getClassLoader()</span>
<span class="fc" id="L151">                                    .getResourceAsStream(source + &quot;.raw&quot;);</span>
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">                    if (inputStream == null) {</span>
<span class="nc" id="L153">                        throw new IllegalStateException(</span>
<span class="nc" id="L154">                                join(</span>
                                        &quot;The MockMethodDispatcher class file is not locatable: &quot;
                                                + source
                                                + &quot;.raw&quot;,
                                        &quot;&quot;,
                                        &quot;The class loader responsible for looking up the resource: &quot;
                                                + InlineDelegateByteBuddyMockMaker.class
<span class="nc" id="L161">                                                        .getClassLoader()));</span>
                    }
<span class="fc" id="L163">                    outputStream.putNextEntry(new JarEntry(source + &quot;.class&quot;));</span>
                    try {
                        int length;
<span class="fc" id="L166">                        byte[] buffer = new byte[1024];</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">                        while ((length = inputStream.read(buffer)) != -1) {</span>
<span class="fc" id="L168">                            outputStream.write(buffer, 0, length);</span>
                        }
                    } finally {
<span class="fc" id="L171">                        inputStream.close();</span>
                    }
<span class="fc" id="L173">                    outputStream.closeEntry();</span>
                } finally {
<span class="fc" id="L175">                    outputStream.close();</span>
                }
<span class="fc" id="L177">                try (JarFile jarfile = new JarFile(boot)) {</span>
<span class="fc" id="L178">                    instrumentation.appendToBootstrapClassLoaderSearch(jarfile);</span>
                }
                try {
<span class="fc" id="L181">                    Class.forName(</span>
                            &quot;org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher&quot;,
                            false,
                            null);
<span class="nc" id="L185">                } catch (ClassNotFoundException cnfe) {</span>
<span class="nc" id="L186">                    throw new IllegalStateException(</span>
<span class="nc" id="L187">                            join(</span>
                                    &quot;Mockito failed to inject the MockMethodDispatcher class into the bootstrap class loader&quot;,
                                    &quot;&quot;,
                                    &quot;It seems like your current VM does not support the instrumentation API correctly.&quot;),
                            cnfe);
<span class="fc" id="L192">                }</span>
<span class="nc" id="L193">            } catch (IOException ioe) {</span>
<span class="nc" id="L194">                throw new IllegalStateException(</span>
<span class="nc" id="L195">                        join(</span>
                                &quot;Mockito could not self-attach a Java agent to the current VM. This feature is required for inline mocking.&quot;,
                                &quot;This error occured due to an I/O error during the creation of this agent: &quot;
                                        + ioe,
                                &quot;&quot;,
                                &quot;Potentially, the current VM does not support the instrumentation API correctly&quot;),
                        ioe);
<span class="fc" id="L202">            }</span>
<span class="fc" id="L203">        } catch (Throwable throwable) {</span>
<span class="fc" id="L204">            instrumentation = null;</span>
<span class="fc" id="L205">            initializationError = throwable;</span>
<span class="fc" id="L206">        }</span>
<span class="fc" id="L207">        INSTRUMENTATION = instrumentation;</span>
<span class="fc" id="L208">        INITIALIZATION_ERROR = initializationError;</span>
<span class="fc" id="L209">    }</span>

    private final BytecodeGenerator bytecodeGenerator;

<span class="fc" id="L213">    private final WeakConcurrentMap&lt;Object, MockMethodInterceptor&gt; mocks =</span>
            new WeakConcurrentMap&lt;&gt;(false);

<span class="fc" id="L216">    private final DetachedThreadLocal&lt;Map&lt;Class&lt;?&gt;, MockMethodInterceptor&gt;&gt; mockedStatics =</span>
            new DetachedThreadLocal&lt;&gt;(DetachedThreadLocal.Cleaner.MANUAL);

<span class="fc" id="L219">    private final DetachedThreadLocal&lt;Map&lt;Class&lt;?&gt;, BiConsumer&lt;Object, MockedConstruction.Context&gt;&gt;&gt;</span>
            mockedConstruction = new DetachedThreadLocal&lt;&gt;(DetachedThreadLocal.Cleaner.MANUAL);

<span class="fc" id="L222">    private final ThreadLocal&lt;Class&lt;?&gt;&gt; currentMocking = ThreadLocal.withInitial(() -&gt; null);</span>

<span class="fc" id="L224">    private final ThreadLocal&lt;Object&gt; currentSpied = new ThreadLocal&lt;&gt;();</span>

<span class="fc" id="L226">    InlineDelegateByteBuddyMockMaker() {</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">        if (INITIALIZATION_ERROR != null) {</span>
            String detail;
<span class="pc bpc" id="L229" title="2 of 4 branches missed.">            if (PlatformUtils.isAndroidPlatform() || PlatformUtils.isProbablyTermuxEnvironment()) {</span>
<span class="nc" id="L230">                detail =</span>
                        &quot;It appears as if you are trying to run this mock maker on Android which does not support the instrumentation API.&quot;;
            } else {
                try {
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">                    if (INITIALIZATION_ERROR instanceof NoClassDefFoundError</span>
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">                            &amp;&amp; INITIALIZATION_ERROR.getMessage() != null</span>
                            &amp;&amp; INITIALIZATION_ERROR
<span class="fc" id="L237">                                    .getMessage()</span>
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">                                    .startsWith(&quot;net/bytebuddy/agent/&quot;)) {</span>
<span class="fc" id="L239">                        detail =</span>
<span class="fc" id="L240">                                join(</span>
                                        &quot;It seems like you are running Mockito with an incomplete or inconsistent class path. Byte Buddy Agent could not be loaded.&quot;,
                                        &quot;&quot;,
                                        &quot;Byte Buddy Agent is available on Maven Central as 'net.bytebuddy:byte-buddy-agent' with the module name 'net.bytebuddy.agent'.&quot;,
                                        &quot;Normally, your IDE or build tool (such as Maven or Gradle) should take care of your class path completion but &quot;);
<span class="nc" id="L245">                    } else if (Class.forName(&quot;javax.tools.ToolProvider&quot;)</span>
<span class="nc" id="L246">                                    .getMethod(&quot;getSystemJavaCompiler&quot;)</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">                                    .invoke(null)</span>
                            == null) {
<span class="nc" id="L249">                        detail =</span>
                                &quot;It appears as if you are running on a JRE. Either install a JDK or add JNA to the class path.&quot;;
                    } else {
<span class="nc" id="L252">                        detail =</span>
                                &quot;It appears as if your JDK does not supply a working agent attachment mechanism.&quot;;
                    }
<span class="nc" id="L255">                } catch (Throwable ignored) {</span>
<span class="nc" id="L256">                    detail =</span>
                            &quot;It appears as if you are running an incomplete JVM installation that might not support all tooling APIs&quot;;
<span class="fc" id="L258">                }</span>
            }
<span class="fc" id="L260">            throw new MockitoInitializationException(</span>
<span class="fc" id="L261">                    join(</span>
                            &quot;Could not initialize inline Byte Buddy mock maker.&quot;,
                            &quot;&quot;,
                            detail,
<span class="fc" id="L265">                            Platform.describe()),</span>
                    INITIALIZATION_ERROR);
        }

<span class="fc" id="L269">        ThreadLocal&lt;Class&lt;?&gt;&gt; currentConstruction = new ThreadLocal&lt;&gt;();</span>
<span class="fc" id="L270">        ThreadLocal&lt;Boolean&gt; isSuspended = ThreadLocal.withInitial(() -&gt; false);</span>
<span class="fc" id="L271">        Predicate&lt;Class&lt;?&gt;&gt; isCallFromSubclassConstructor = StackWalkerChecker.orFallback();</span>
<span class="fc" id="L272">        Predicate&lt;Class&lt;?&gt;&gt; isMockConstruction =</span>
                type -&gt; {
<span class="fc bfc" id="L274" title="All 2 branches covered.">                    if (isSuspended.get()) {</span>
<span class="fc" id="L275">                        return false;</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">                    } else if ((currentMocking.get() != null</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">                                    &amp;&amp; type.isAssignableFrom(currentMocking.get()))</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">                            || currentConstruction.get() != null) {</span>
<span class="fc" id="L279">                        return true;</span>
                    }
<span class="fc" id="L281">                    Map&lt;Class&lt;?&gt;, ?&gt; interceptors = mockedConstruction.get();</span>
<span class="fc bfc" id="L282" title="All 4 branches covered.">                    if (interceptors != null &amp;&amp; interceptors.containsKey(type)) {</span>
                        // We only initiate a construction mock, if the call originates from an
                        // un-mocked (as suppression is not enabled) subclass constructor.
<span class="fc bfc" id="L285" title="All 2 branches covered.">                        if (isCallFromSubclassConstructor.test(type)) {</span>
<span class="fc" id="L286">                            return false;</span>
                        }
<span class="fc" id="L288">                        currentConstruction.set(type);</span>
<span class="fc" id="L289">                        return true;</span>
                    } else {
<span class="fc" id="L291">                        return false;</span>
                    }
                };
<span class="fc" id="L294">        ConstructionCallback onConstruction =</span>
                (type, object, arguments, parameterTypeNames) -&gt; {
<span class="fc bfc" id="L296" title="All 2 branches covered.">                    if (currentMocking.get() != null) {</span>
<span class="fc" id="L297">                        Object spy = currentSpied.get();</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">                        if (spy == null) {</span>
<span class="fc" id="L299">                            return null;</span>
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">                        } else if (type.isInstance(spy)) {</span>
<span class="fc" id="L301">                            return spy;</span>
                        } else {
<span class="nc" id="L303">                            isSuspended.set(true);</span>
                            try {
                                // Unexpected construction of non-spied object
<span class="nc" id="L306">                                throw new MockitoException(</span>
                                        &quot;Unexpected spy for &quot;
<span class="nc" id="L308">                                                + type.getName()</span>
                                                + &quot; on instance of &quot;
<span class="nc" id="L310">                                                + object.getClass().getName(),</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">                                        object instanceof Throwable ? (Throwable) object : null);</span>
                            } finally {
<span class="nc" id="L313">                                isSuspended.set(false);</span>
                            }
                        }
<span class="fc bfc" id="L316" title="All 2 branches covered.">                    } else if (currentConstruction.get() != type) {</span>
<span class="fc" id="L317">                        return null;</span>
                    }
<span class="fc" id="L319">                    currentConstruction.remove();</span>
<span class="fc" id="L320">                    isSuspended.set(true);</span>
                    try {
<span class="fc" id="L322">                        Map&lt;Class&lt;?&gt;, BiConsumer&lt;Object, MockedConstruction.Context&gt;&gt; interceptors =</span>
<span class="fc" id="L323">                                mockedConstruction.get();</span>
<span class="pc bpc" id="L324" title="1 of 2 branches missed.">                        if (interceptors != null) {</span>
<span class="fc" id="L325">                            BiConsumer&lt;Object, MockedConstruction.Context&gt; interceptor =</span>
<span class="fc" id="L326">                                    interceptors.get(type);</span>
<span class="pc bpc" id="L327" title="1 of 2 branches missed.">                            if (interceptor != null) {</span>
<span class="fc" id="L328">                                interceptor.accept(</span>
                                        object,
                                        new InlineConstructionMockContext(
<span class="fc" id="L331">                                                arguments, object.getClass(), parameterTypeNames));</span>
                            }
                        }
                    } finally {
<span class="fc" id="L335">                        isSuspended.set(false);</span>
                    }
<span class="fc" id="L337">                    return null;</span>
                };

<span class="fc" id="L340">        bytecodeGenerator =</span>
                new TypeCachingBytecodeGenerator(
                        new InlineBytecodeGenerator(
                                INSTRUMENTATION,
                                mocks,
                                mockedStatics,
                                isMockConstruction,
                                onConstruction),
                        true);
<span class="fc" id="L349">    }</span>

    @Override
    public &lt;T&gt; T createMock(MockCreationSettings&lt;T&gt; settings, MockHandler handler) {
<span class="fc" id="L353">        return doCreateMock(settings, handler, false);</span>
    }

    @Override
    public &lt;T&gt; Optional&lt;T&gt; createSpy(
            MockCreationSettings&lt;T&gt; settings, MockHandler handler, T object) {
<span class="pc bpc" id="L359" title="1 of 2 branches missed.">        if (object == null) {</span>
<span class="nc" id="L360">            throw new MockitoConfigurationException(&quot;Spy instance must not be null&quot;);</span>
        }
<span class="fc" id="L362">        currentSpied.set(object);</span>
        try {
<span class="fc" id="L364">            return Optional.ofNullable(doCreateMock(settings, handler, true));</span>
        } finally {
<span class="fc" id="L366">            currentSpied.remove();</span>
        }
    }

    private &lt;T&gt; T doCreateMock(
            MockCreationSettings&lt;T&gt; settings,
            MockHandler handler,
            boolean nullOnNonInlineConstruction) {
<span class="fc" id="L374">        Class&lt;? extends T&gt; type = createMockType(settings);</span>

        try {
            T instance;
<span class="fc bfc" id="L378" title="All 2 branches covered.">            if (settings.isUsingConstructor()) {</span>
<span class="fc" id="L379">                instance =</span>
                        new ConstructorInstantiator(
<span class="fc bfc" id="L381" title="All 2 branches covered.">                                        settings.getOuterClassInstance() != null,</span>
<span class="fc" id="L382">                                        settings.getConstructorArgs())</span>
<span class="fc" id="L383">                                .newInstance(type);</span>
            } else {
                try {
                    // We attempt to use the &quot;native&quot; mock maker first that avoids
                    // Objenesis and Unsafe
<span class="fc" id="L388">                    instance = newInstance(type);</span>
<span class="fc" id="L389">                } catch (InstantiationException ignored) {</span>
<span class="pc bpc" id="L390" title="1 of 2 branches missed.">                    if (nullOnNonInlineConstruction) {</span>
<span class="nc" id="L391">                        return null;</span>
                    }
                    Instantiator instantiator =
<span class="fc" id="L394">                            Plugins.getInstantiatorProvider().getInstantiator(settings);</span>
<span class="fc" id="L395">                    instance = instantiator.newInstance(type);</span>
<span class="fc" id="L396">                }</span>
            }
<span class="fc" id="L398">            MockMethodInterceptor mockMethodInterceptor =</span>
                    new MockMethodInterceptor(handler, settings);
<span class="fc" id="L400">            mocks.put(instance, mockMethodInterceptor);</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">            if (instance instanceof MockAccess) {</span>
<span class="fc" id="L402">                ((MockAccess) instance).setMockitoInterceptor(mockMethodInterceptor);</span>
            }
<span class="fc" id="L404">            mocks.expungeStaleEntries();</span>
<span class="fc" id="L405">            return instance;</span>
<span class="fc" id="L406">        } catch (InstantiationException e) {</span>
<span class="fc" id="L407">            throw new MockitoException(</span>
<span class="fc" id="L408">                    &quot;Unable to create mock instance of type '&quot; + type.getSimpleName() + &quot;'&quot;, e);</span>
        }
    }

    @Override
    public &lt;T&gt; Class&lt;? extends T&gt; createMockType(MockCreationSettings&lt;T&gt; settings) {
        try {
<span class="fc" id="L415">            return bytecodeGenerator.mockClass(</span>
<span class="fc" id="L416">                    MockFeatures.withMockFeatures(</span>
<span class="fc" id="L417">                            settings.getTypeToMock(),</span>
<span class="fc" id="L418">                            settings.getExtraInterfaces(),</span>
<span class="fc" id="L419">                            settings.getSerializableMode(),</span>
<span class="fc" id="L420">                            settings.isStripAnnotations(),</span>
<span class="fc" id="L421">                            settings.getDefaultAnswer()));</span>
<span class="fc" id="L422">        } catch (Exception bytecodeGenerationFailed) {</span>
<span class="nc" id="L423">            throw prettifyFailure(settings, bytecodeGenerationFailed);</span>
        }
    }

    private &lt;T&gt; RuntimeException prettifyFailure(
            MockCreationSettings&lt;T&gt; mockFeatures, Exception generationFailed) {
<span class="fc" id="L429">        Class&lt;T&gt; typeToMock = mockFeatures.getTypeToMock();</span>
<span class="fc bfc" id="L430" title="All 2 branches covered.">        if (typeToMock.isArray()) {</span>
<span class="fc" id="L431">            throw new MockitoException(</span>
<span class="fc" id="L432">                    join(&quot;Arrays cannot be mocked: &quot; + typeToMock + &quot;.&quot;, &quot;&quot;), generationFailed);</span>
        }
<span class="fc bfc" id="L434" title="All 2 branches covered.">        if (Modifier.isFinal(typeToMock.getModifiers())) {</span>
<span class="fc" id="L435">            throw new MockitoException(</span>
<span class="fc" id="L436">                    join(</span>
                            &quot;Mockito cannot mock this class: &quot; + typeToMock + &quot;.&quot;,
                            &quot;Can not mock final classes with the following settings :&quot;,
                            &quot; - explicit serialization (e.g. withSettings().serializable())&quot;,
                            &quot; - extra interfaces (e.g. withSettings().extraInterfaces(...))&quot;,
                            &quot;&quot;,
                            &quot;You are seeing this disclaimer because Mockito is configured to create inlined mocks.&quot;,
                            &quot;You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.&quot;,
                            &quot;&quot;,
                            &quot;Underlying exception : &quot; + generationFailed),
                    generationFailed);
        }
<span class="pc bpc" id="L448" title="2 of 4 branches missed.">        if (TypeSupport.INSTANCE.isSealed(typeToMock) &amp;&amp; typeToMock.isEnum()) {</span>
<span class="fc" id="L449">            throw new MockitoException(</span>
<span class="fc" id="L450">                    join(</span>
                            &quot;Mockito cannot mock this class: &quot; + typeToMock + &quot;.&quot;,
                            &quot;Sealed abstract enums can't be mocked. Since Java 15 abstract enums are declared sealed, which prevents mocking.&quot;,
                            &quot;You can still return an existing enum literal from a stubbed method call.&quot;),
                    generationFailed);
        }
<span class="nc bnc" id="L456" title="All 2 branches missed.">        if (Modifier.isPrivate(typeToMock.getModifiers())) {</span>
<span class="nc" id="L457">            throw new MockitoException(</span>
<span class="nc" id="L458">                    join(</span>
                            &quot;Mockito cannot mock this class: &quot; + typeToMock + &quot;.&quot;,
                            &quot;Most likely it is a private class that is not visible by Mockito&quot;,
                            &quot;&quot;,
                            &quot;You are seeing this disclaimer because Mockito is configured to create inlined mocks.&quot;,
                            &quot;You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.&quot;,
                            &quot;&quot;),
                    generationFailed);
        }
<span class="nc" id="L467">        throw new MockitoException(</span>
<span class="nc" id="L468">                join(</span>
                        &quot;Mockito cannot mock this class: &quot; + typeToMock + &quot;.&quot;,
                        &quot;&quot;,
                        &quot;If you're not sure why you're getting this error, please open an issue on GitHub.&quot;,
                        &quot;&quot;,
<span class="nc" id="L473">                        Platform.warnForVM(</span>
                                &quot;IBM J9 VM&quot;,
                                &quot;Early IBM virtual machine are known to have issues with Mockito, please upgrade to an up-to-date version.\n&quot;,
                                &quot;Hotspot&quot;,
                                &quot;&quot;),
<span class="nc" id="L478">                        Platform.describe(),</span>
                        &quot;&quot;,
                        &quot;You are seeing this disclaimer because Mockito is configured to create inlined mocks.&quot;,
                        &quot;You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.&quot;,
                        &quot;&quot;,
                        &quot;Underlying exception : &quot; + generationFailed),
                generationFailed);
    }

    @Override
    public MockHandler getHandler(Object mock) {
        MockMethodInterceptor interceptor;
<span class="fc bfc" id="L490" title="All 2 branches covered.">        if (mock instanceof Class&lt;?&gt;) {</span>
<span class="fc" id="L491">            Map&lt;Class&lt;?&gt;, MockMethodInterceptor&gt; interceptors = mockedStatics.get();</span>
<span class="pc bpc" id="L492" title="1 of 2 branches missed.">            interceptor = interceptors != null ? interceptors.get(mock) : null;</span>
<span class="fc" id="L493">        } else {</span>
<span class="fc" id="L494">            interceptor = mocks.get(mock);</span>
        }
<span class="fc bfc" id="L496" title="All 2 branches covered.">        if (interceptor == null) {</span>
<span class="fc" id="L497">            return null;</span>
        } else {
<span class="fc" id="L499">            return interceptor.handler;</span>
        }
    }

    @Override
    public void resetMock(Object mock, MockHandler newHandler, MockCreationSettings settings) {
<span class="fc" id="L505">        MockMethodInterceptor mockMethodInterceptor =</span>
                new MockMethodInterceptor(newHandler, settings);
<span class="fc bfc" id="L507" title="All 2 branches covered.">        if (mock instanceof Class&lt;?&gt;) {</span>
<span class="fc" id="L508">            Map&lt;Class&lt;?&gt;, MockMethodInterceptor&gt; interceptors = mockedStatics.get();</span>
<span class="pc bpc" id="L509" title="2 of 4 branches missed.">            if (interceptors == null || !interceptors.containsKey(mock)) {</span>
<span class="nc" id="L510">                throw new MockitoException(</span>
                        &quot;Cannot reset &quot;
                                + mock
                                + &quot; which is not currently registered as a static mock&quot;);
            }
<span class="fc" id="L515">            interceptors.put((Class&lt;?&gt;) mock, mockMethodInterceptor);</span>
<span class="fc" id="L516">        } else {</span>
<span class="pc bpc" id="L517" title="1 of 2 branches missed.">            if (!mocks.containsKey(mock)) {</span>
<span class="nc" id="L518">                throw new MockitoException(</span>
                        &quot;Cannot reset &quot; + mock + &quot; which is not currently registered as a mock&quot;);
            }
<span class="fc" id="L521">            mocks.put(mock, mockMethodInterceptor);</span>
<span class="fc bfc" id="L522" title="All 2 branches covered.">            if (mock instanceof MockAccess) {</span>
<span class="fc" id="L523">                ((MockAccess) mock).setMockitoInterceptor(mockMethodInterceptor);</span>
            }
<span class="fc" id="L525">            mocks.expungeStaleEntries();</span>
        }
<span class="fc" id="L527">    }</span>

    @Override
    public void clearAllCaches() {
<span class="fc" id="L531">        clearAllMocks();</span>
<span class="fc" id="L532">        bytecodeGenerator.clearAllCaches();</span>
<span class="fc" id="L533">    }</span>

    @Override
    public void clearMock(Object mock) {
<span class="pc bpc" id="L537" title="1 of 2 branches missed.">        if (mock instanceof Class&lt;?&gt;) {</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">            for (Map&lt;Class&lt;?&gt;, ?&gt; entry : mockedStatics.getBackingMap().target.values()) {</span>
<span class="nc" id="L539">                entry.remove(mock);</span>
<span class="nc" id="L540">            }</span>
        } else {
<span class="fc" id="L542">            mocks.remove(mock);</span>
        }
<span class="fc" id="L544">    }</span>

    @Override
    public void clearAllMocks() {
<span class="fc" id="L548">        mockedStatics.getBackingMap().clear();</span>
<span class="fc" id="L549">        mocks.clear();</span>
<span class="fc" id="L550">    }</span>

    @Override
    public TypeMockability isTypeMockable(final Class&lt;?&gt; type) {
<span class="fc" id="L554">        return new TypeMockability() {</span>
            @Override
            public boolean mockable() {
<span class="fc bfc" id="L557" title="All 4 branches covered.">                return INSTRUMENTATION.isModifiableClass(type) &amp;&amp; !EXCLUDES.contains(type);</span>
            }

            @Override
            public String nonMockableReason() {
<span class="fc bfc" id="L562" title="All 2 branches covered.">                if (mockable()) {</span>
<span class="fc" id="L563">                    return &quot;&quot;;</span>
                }
<span class="fc bfc" id="L565" title="All 2 branches covered.">                if (type.isPrimitive()) {</span>
<span class="fc" id="L566">                    return &quot;primitive type&quot;;</span>
                }
<span class="fc bfc" id="L568" title="All 2 branches covered.">                if (EXCLUDES.contains(type)) {</span>
<span class="fc" id="L569">                    return &quot;Cannot mock wrapper types, String.class or Class.class&quot;;</span>
                }
<span class="fc" id="L571">                return &quot;VM does not support modification of given type&quot;;</span>
            }
        };
    }

    @Override
    public &lt;T&gt; StaticMockControl&lt;T&gt; createStaticMock(
            Class&lt;T&gt; type, MockCreationSettings&lt;T&gt; settings, MockHandler handler) {
<span class="pc bpc" id="L579" title="1 of 2 branches missed.">        if (type == ConcurrentHashMap.class) {</span>
<span class="nc" id="L580">            throw new MockitoException(</span>
                    &quot;It is not possible to mock static methods of ConcurrentHashMap &quot;
                            + &quot;to avoid infinitive loops within Mockito's implementation of static mock handling&quot;);
<span class="pc bpc" id="L583" title="3 of 6 branches missed.">        } else if (type == Thread.class</span>
                || type == System.class
                || type == Arrays.class
<span class="pc bpc" id="L586" title="1 of 2 branches missed.">                || ClassLoader.class.isAssignableFrom(type)) {</span>
<span class="nc" id="L587">            throw new MockitoException(</span>
                    &quot;It is not possible to mock static methods of &quot;
<span class="nc" id="L589">                            + type.getName()</span>
                            + &quot; to avoid interfering with class loading what leads to infinite loops&quot;);
        }

<span class="fc" id="L593">        bytecodeGenerator.mockClassStatic(type);</span>

<span class="fc" id="L595">        Map&lt;Class&lt;?&gt;, MockMethodInterceptor&gt; interceptors = mockedStatics.get();</span>
<span class="fc bfc" id="L596" title="All 2 branches covered.">        if (interceptors == null) {</span>
<span class="fc" id="L597">            interceptors = new WeakHashMap&lt;&gt;();</span>
<span class="fc" id="L598">            mockedStatics.set(interceptors);</span>
        }
<span class="fc" id="L600">        mockedStatics.getBackingMap().expungeStaleEntries();</span>

<span class="fc" id="L602">        return new InlineStaticMockControl&lt;&gt;(type, interceptors, settings, handler);</span>
    }

    @Override
    public &lt;T&gt; ConstructionMockControl&lt;T&gt; createConstructionMock(
            Class&lt;T&gt; type,
            Function&lt;MockedConstruction.Context, MockCreationSettings&lt;T&gt;&gt; settingsFactory,
            Function&lt;MockedConstruction.Context, MockHandler&lt;T&gt;&gt; handlerFactory,
            MockedConstruction.MockInitializer&lt;T&gt; mockInitializer) {
<span class="fc bfc" id="L611" title="All 2 branches covered.">        if (type == Object.class) {</span>
<span class="fc" id="L612">            throw new MockitoException(</span>
                    &quot;It is not possible to mock construction of the Object class &quot;
                            + &quot;to avoid inference with default object constructor chains&quot;);
<span class="pc bpc" id="L615" title="1 of 4 branches missed.">        } else if (type.isPrimitive() || Modifier.isAbstract(type.getModifiers())) {</span>
<span class="fc" id="L616">            throw new MockitoException(</span>
                    &quot;It is not possible to construct primitive types or abstract types: &quot;
<span class="fc" id="L618">                            + type.getName());</span>
        }

<span class="fc" id="L621">        bytecodeGenerator.mockClassConstruction(type);</span>

<span class="fc" id="L623">        Map&lt;Class&lt;?&gt;, BiConsumer&lt;Object, MockedConstruction.Context&gt;&gt; interceptors =</span>
<span class="fc" id="L624">                mockedConstruction.get();</span>
<span class="fc bfc" id="L625" title="All 2 branches covered.">        if (interceptors == null) {</span>
<span class="fc" id="L626">            interceptors = new WeakHashMap&lt;&gt;();</span>
<span class="fc" id="L627">            mockedConstruction.set(interceptors);</span>
        }
<span class="fc" id="L629">        mockedConstruction.getBackingMap().expungeStaleEntries();</span>

<span class="fc" id="L631">        return new InlineConstructionMockControl&lt;&gt;(</span>
                type, settingsFactory, handlerFactory, mockInitializer, interceptors);
    }

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T&gt; T newInstance(Class&lt;T&gt; cls) throws InstantiationException {
<span class="fc" id="L638">        Constructor&lt;?&gt;[] constructors = cls.getDeclaredConstructors();</span>
<span class="fc bfc" id="L639" title="All 2 branches covered.">        if (constructors.length == 0) {</span>
<span class="fc" id="L640">            throw new InstantiationException(cls.getName() + &quot; does not define a constructor&quot;);</span>
        }
<span class="fc" id="L642">        Constructor&lt;?&gt; selected = constructors[0];</span>
<span class="fc bfc" id="L643" title="All 2 branches covered.">        for (Constructor&lt;?&gt; constructor : constructors) {</span>
<span class="fc bfc" id="L644" title="All 2 branches covered.">            if (Modifier.isPublic(constructor.getModifiers())) {</span>
<span class="fc" id="L645">                selected = constructor;</span>
<span class="fc" id="L646">                break;</span>
            }
        }
<span class="fc" id="L649">        Class&lt;?&gt;[] types = selected.getParameterTypes();</span>
<span class="fc" id="L650">        Object[] arguments = new Object[types.length];</span>
<span class="fc" id="L651">        int index = 0;</span>
<span class="fc bfc" id="L652" title="All 2 branches covered.">        for (Class&lt;?&gt; type : types) {</span>
<span class="fc" id="L653">            arguments[index++] = makeStandardArgument(type);</span>
        }
<span class="fc" id="L655">        MemberAccessor accessor = Plugins.getMemberAccessor();</span>
        try {
<span class="fc" id="L657">            return (T)</span>
<span class="fc" id="L658">                    accessor.newInstance(</span>
                            selected,
                            callback -&gt; {
<span class="fc" id="L661">                                currentMocking.set(cls);</span>
                                try {
<span class="fc" id="L663">                                    return callback.newInstance();</span>
                                } finally {
<span class="fc" id="L665">                                    currentMocking.remove();</span>
                                }
                            },
                            arguments);
<span class="nc" id="L669">        } catch (Exception e) {</span>
<span class="nc" id="L670">            throw new InstantiationException(&quot;Could not instantiate &quot; + cls.getName(), e);</span>
        }
    }

    private Object makeStandardArgument(Class&lt;?&gt; type) {
<span class="fc bfc" id="L675" title="All 2 branches covered.">        if (type == boolean.class) {</span>
<span class="fc" id="L676">            return false;</span>
<span class="fc bfc" id="L677" title="All 2 branches covered.">        } else if (type == byte.class) {</span>
<span class="fc" id="L678">            return (byte) 0;</span>
<span class="fc bfc" id="L679" title="All 2 branches covered.">        } else if (type == short.class) {</span>
<span class="fc" id="L680">            return (short) 0;</span>
<span class="fc bfc" id="L681" title="All 2 branches covered.">        } else if (type == char.class) {</span>
<span class="fc" id="L682">            return (char) 0;</span>
<span class="fc bfc" id="L683" title="All 2 branches covered.">        } else if (type == int.class) {</span>
<span class="fc" id="L684">            return 0;</span>
<span class="fc bfc" id="L685" title="All 2 branches covered.">        } else if (type == long.class) {</span>
<span class="fc" id="L686">            return 0L;</span>
<span class="fc bfc" id="L687" title="All 2 branches covered.">        } else if (type == float.class) {</span>
<span class="fc" id="L688">            return 0f;</span>
<span class="fc bfc" id="L689" title="All 2 branches covered.">        } else if (type == double.class) {</span>
<span class="fc" id="L690">            return 0d;</span>
        } else {
<span class="fc" id="L692">            return null;</span>
        }
    }

    private static class InlineStaticMockControl&lt;T&gt; implements StaticMockControl&lt;T&gt; {

        private final Class&lt;T&gt; type;

        private final Map&lt;Class&lt;?&gt;, MockMethodInterceptor&gt; interceptors;

        private final MockCreationSettings&lt;T&gt; settings;

        private final MockHandler handler;

        private InlineStaticMockControl(
                Class&lt;T&gt; type,
                Map&lt;Class&lt;?&gt;, MockMethodInterceptor&gt; interceptors,
                MockCreationSettings&lt;T&gt; settings,
<span class="fc" id="L710">                MockHandler handler) {</span>
<span class="fc" id="L711">            this.type = type;</span>
<span class="fc" id="L712">            this.interceptors = interceptors;</span>
<span class="fc" id="L713">            this.settings = settings;</span>
<span class="fc" id="L714">            this.handler = handler;</span>
<span class="fc" id="L715">        }</span>

        @Override
        public Class&lt;T&gt; getType() {
<span class="fc" id="L719">            return type;</span>
        }

        @Override
        public void enable() {
<span class="fc bfc" id="L724" title="All 2 branches covered.">            if (interceptors.putIfAbsent(type, new MockMethodInterceptor(handler, settings))</span>
                    != null) {
<span class="fc" id="L726">                throw new MockitoException(</span>
<span class="fc" id="L727">                        join(</span>
                                &quot;For &quot;
<span class="fc" id="L729">                                        + type.getName()</span>
                                        + &quot;, static mocking is already registered in the current thread&quot;,
                                &quot;&quot;,
                                &quot;To create a new mock, the existing static mock registration must be deregistered&quot;));
            }
<span class="fc" id="L734">        }</span>

        @Override
        public void disable() {
<span class="pc bpc" id="L738" title="1 of 2 branches missed.">            if (interceptors.remove(type) == null) {</span>
<span class="nc" id="L739">                throw new MockitoException(</span>
<span class="nc" id="L740">                        join(</span>
                                &quot;Could not deregister &quot;
<span class="nc" id="L742">                                        + type.getName()</span>
                                        + &quot; as a static mock since it is not currently registered&quot;,
                                &quot;&quot;,
                                &quot;To register a static mock, use Mockito.mockStatic(&quot;
<span class="nc" id="L746">                                        + type.getSimpleName()</span>
                                        + &quot;.class)&quot;));
            }
<span class="fc" id="L749">        }</span>
    }

    private class InlineConstructionMockControl&lt;T&gt; implements ConstructionMockControl&lt;T&gt; {

        private final Class&lt;T&gt; type;

        private final Function&lt;MockedConstruction.Context, MockCreationSettings&lt;T&gt;&gt; settingsFactory;
        private final Function&lt;MockedConstruction.Context, MockHandler&lt;T&gt;&gt; handlerFactory;

        private final MockedConstruction.MockInitializer&lt;T&gt; mockInitializer;

        private final Map&lt;Class&lt;?&gt;, BiConsumer&lt;Object, MockedConstruction.Context&gt;&gt; interceptors;

<span class="fc" id="L763">        private final List&lt;Object&gt; all = new ArrayList&lt;&gt;();</span>
        private int count;

        private InlineConstructionMockControl(
                Class&lt;T&gt; type,
                Function&lt;MockedConstruction.Context, MockCreationSettings&lt;T&gt;&gt; settingsFactory,
                Function&lt;MockedConstruction.Context, MockHandler&lt;T&gt;&gt; handlerFactory,
                MockedConstruction.MockInitializer&lt;T&gt; mockInitializer,
<span class="fc" id="L771">                Map&lt;Class&lt;?&gt;, BiConsumer&lt;Object, MockedConstruction.Context&gt;&gt; interceptors) {</span>
<span class="fc" id="L772">            this.type = type;</span>
<span class="fc" id="L773">            this.settingsFactory = settingsFactory;</span>
<span class="fc" id="L774">            this.handlerFactory = handlerFactory;</span>
<span class="fc" id="L775">            this.mockInitializer = mockInitializer;</span>
<span class="fc" id="L776">            this.interceptors = interceptors;</span>
<span class="fc" id="L777">        }</span>

        @Override
        public Class&lt;T&gt; getType() {
<span class="nc" id="L781">            return type;</span>
        }

        @Override
        public void enable() {
<span class="fc bfc" id="L786" title="All 2 branches covered.">            if (interceptors.putIfAbsent(</span>
                            type,
                            (object, context) -&gt; {
<span class="fc" id="L789">                                ((InlineConstructionMockContext) context).count = ++count;</span>
<span class="fc" id="L790">                                MockMethodInterceptor interceptor =</span>
                                        new MockMethodInterceptor(
<span class="fc" id="L792">                                                handlerFactory.apply(context),</span>
<span class="fc" id="L793">                                                settingsFactory.apply(context));</span>
<span class="fc" id="L794">                                mocks.put(object, interceptor);</span>
                                try {
                                    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L797">                                    T cast = (T) object;</span>
<span class="fc" id="L798">                                    mockInitializer.prepare(cast, context);</span>
<span class="nc" id="L799">                                } catch (Throwable t) {</span>
<span class="nc" id="L800">                                    mocks.remove(object); // TODO: filter stack trace?</span>
<span class="nc" id="L801">                                    throw new MockitoException(</span>
                                            &quot;Could not initialize mocked construction&quot;, t);
<span class="fc" id="L803">                                }</span>
<span class="fc" id="L804">                                all.add(object);</span>
<span class="fc" id="L805">                            })</span>
                    != null) {
<span class="fc" id="L807">                throw new MockitoException(</span>
<span class="fc" id="L808">                        join(</span>
                                &quot;For &quot;
<span class="fc" id="L810">                                        + type.getName()</span>
                                        + &quot;, static mocking is already registered in the current thread&quot;,
                                &quot;&quot;,
                                &quot;To create a new mock, the existing static mock registration must be deregistered&quot;));
            }
<span class="fc" id="L815">        }</span>

        @Override
        public void disable() {
<span class="pc bpc" id="L819" title="1 of 2 branches missed.">            if (interceptors.remove(type) == null) {</span>
<span class="nc" id="L820">                throw new MockitoException(</span>
<span class="nc" id="L821">                        join(</span>
                                &quot;Could not deregister &quot;
<span class="nc" id="L823">                                        + type.getName()</span>
                                        + &quot; as a static mock since it is not currently registered&quot;,
                                &quot;&quot;,
                                &quot;To register a static mock, use Mockito.mockStatic(&quot;
<span class="nc" id="L827">                                        + type.getSimpleName()</span>
                                        + &quot;.class)&quot;));
            }
<span class="fc" id="L830">            all.clear();</span>
<span class="fc" id="L831">        }</span>

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public List&lt;T&gt; getMocks() {
<span class="fc" id="L836">            return (List&lt;T&gt;) all;</span>
        }
    }

    private static class InlineConstructionMockContext implements MockedConstruction.Context {

<span class="fc" id="L842">        private static final Map&lt;String, Class&lt;?&gt;&gt; PRIMITIVES = new HashMap&lt;&gt;();</span>

        static {
<span class="fc" id="L845">            PRIMITIVES.put(boolean.class.getName(), boolean.class);</span>
<span class="fc" id="L846">            PRIMITIVES.put(byte.class.getName(), byte.class);</span>
<span class="fc" id="L847">            PRIMITIVES.put(short.class.getName(), short.class);</span>
<span class="fc" id="L848">            PRIMITIVES.put(char.class.getName(), char.class);</span>
<span class="fc" id="L849">            PRIMITIVES.put(int.class.getName(), int.class);</span>
<span class="fc" id="L850">            PRIMITIVES.put(long.class.getName(), long.class);</span>
<span class="fc" id="L851">            PRIMITIVES.put(float.class.getName(), float.class);</span>
<span class="fc" id="L852">            PRIMITIVES.put(double.class.getName(), double.class);</span>
<span class="fc" id="L853">        }</span>

        private int count;

        private final Object[] arguments;
        private final Class&lt;?&gt; type;
        private final String[] parameterTypeNames;

        private InlineConstructionMockContext(
<span class="fc" id="L862">                Object[] arguments, Class&lt;?&gt; type, String[] parameterTypeNames) {</span>
<span class="fc" id="L863">            this.arguments = arguments;</span>
<span class="fc" id="L864">            this.type = type;</span>
<span class="fc" id="L865">            this.parameterTypeNames = parameterTypeNames;</span>
<span class="fc" id="L866">        }</span>

        @Override
        public int getCount() {
<span class="pc bpc" id="L870" title="1 of 2 branches missed.">            if (count == 0) {</span>
<span class="nc" id="L871">                throw new MockitoConfigurationException(</span>
                        &quot;mocked construction context is not initialized&quot;);
            }
<span class="fc" id="L874">            return count;</span>
        }

        @Override
        public Constructor&lt;?&gt; constructor() {
<span class="fc" id="L879">            Class&lt;?&gt;[] parameterTypes = new Class&lt;?&gt;[parameterTypeNames.length];</span>
<span class="fc" id="L880">            int index = 0;</span>
<span class="fc bfc" id="L881" title="All 2 branches covered.">            for (String parameterTypeName : parameterTypeNames) {</span>
<span class="pc bpc" id="L882" title="1 of 2 branches missed.">                if (PRIMITIVES.containsKey(parameterTypeName)) {</span>
<span class="nc" id="L883">                    parameterTypes[index++] = PRIMITIVES.get(parameterTypeName);</span>
                } else {
                    try {
<span class="fc" id="L886">                        parameterTypes[index++] =</span>
<span class="fc" id="L887">                                Class.forName(parameterTypeName, false, type.getClassLoader());</span>
<span class="nc" id="L888">                    } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L889">                        throw new MockitoException(</span>
                                &quot;Could not find parameter of type &quot; + parameterTypeName, e);
<span class="fc" id="L891">                    }</span>
                }
            }
            try {
<span class="fc" id="L895">                return type.getDeclaredConstructor(parameterTypes);</span>
<span class="nc" id="L896">            } catch (NoSuchMethodException e) {</span>
<span class="nc" id="L897">                throw new MockitoException(</span>
<span class="nc" id="L898">                        join(</span>
                                &quot;Could not resolve constructor of type&quot;,
                                &quot;&quot;,
<span class="nc" id="L901">                                type.getName(),</span>
                                &quot;&quot;,
                                &quot;with arguments of types&quot;,
<span class="nc" id="L904">                                Arrays.toString(parameterTypes)),</span>
                        e);
            }
        }

        @Override
        public List&lt;?&gt; arguments() {
<span class="fc" id="L911">            return Collections.unmodifiableList(Arrays.asList(arguments));</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>